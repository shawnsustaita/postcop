#!/usr/bin/env perl


### MODULES
use strict;
use warnings;
use IO::File;
use File::stat;
use Sys::Syslog           qw/setlogsock openlog syslog/;
use Fcntl                 qw/:DEFAULT :flock/;
use POSIX                 qw/setsid sysconf _SC_OPEN_MAX WNOHANG/;
use IO::Socket::INET;
use Email::Sender::Simple qw/try_to_sendmail/;
use Linux::Inotify2;
use DBM::Deep;
use List::MoreUtils       qw/any none/;


### CONFIGURATION FILE GLOBALS
my $debug                = 1;
my $foreground           = 0;
my $alarm_time           = 5;
my $jail_time            = 15;
my $send_threshold       = 3;
my $syslog_facility      = 'local0';
my $syslog_priority      = 'warning';
my $syslog_socktype      = 'unix';
my $maillog_file         = '/var/log/mail.log';
my $tmpworkdir           = '/var/lib/postcop';
my $pardon_file          = '/etc/postfix/postcop_pardons';
my $jail_file            = '/etc/postfix/postcop_jailings';
my $pid_file             = '/var/run/postcopd.pid';
my $postfix_access       = 'DISCARD Email rate limit exceeded.';
my $postmap_cmd          = "/usr/sbin/postmap $jail_file";
my $postsuper_cmd        = '/usr/sbin/postsuper -d-';  # Must read stdin!
my $listen_port          = 666;
my $listen_address       = '192.168.0.6';
my @peers                = qw/192.168.0.6/;
my $from                 = 'postcop@localhost';
my $to                   = 'root@localhost';
my $subject              = 'Postcop Jailings';

# Regexp that parses Postfix postmap file.
my $jailing_regexp       = qr{
    \A             # Anchor to beginning of srtring
    ([^\s]+)       # Capture inmate (ie sender addr)
    [\s]+          # Whitespace
    .*             # Match anything ($postfix_access)
    [\s]           # Whitespace
    \[([0-9]+)\]   # Capture jail time seconds
    \s*            # Whitespace
    \z             # Anchor to end of string
}xmsio;

# Regexp that parses Postfix mail logs.
my $maillog_regexp       = qr{
    \A             # Anchor to beginning of srtring
    .*             # Match anything (including newline)
    \s             # Whitespace
    (.*?):         # Capture mail ID
    \s             # Whitespace
    from=<(.*?)>,  # Capture sender email address
    \s             # Whitespace
    size=.*?,      # Mail size (don't care)
    \s             # Whitespace
    nrcpt=(\d+)    # Capture number of recipients
    .*             # Match anything (including newline)
    \z             # Anchor to end of string
}xmsio;


### NON-CONFIGURATION FILE GLOBALS (INTERNALS)
my $done                 =  0;
my $alarm                =  0;
my $maillog_rotated      =  0;
my $maillog_inode        = -1;
my $max_peer_connections =  2;
my $pid_fh;
my $maillog_fh;
my $inotify;
my $listener;
my %sender_mail_ids;
my %sender_mail_logs;
my %sender_mail_counts;
my %pardons;
my %inmates;
my %new_inmates;
my %peer_inmates;
my $header               =  [ To      => $to,
                              From    => $from,
                              Subject => $subject ];


### DECLARATIONS
sub main;
sub initialize;
sub finalize;
sub init_signals;
sub init_syslog;
sub daemonize;
sub create_locked_pid_file;
sub open_file_with_lock;
sub service_peer;
sub tcp_network_server;
sub init_maillog;
sub Log;
sub tie_db_vars;
sub init_db_vars;
sub is_pardoned;
sub is_inmate;
sub is_peer_inmate;
sub process_maillogs;
sub process_pardons;
sub process_inmates;
sub process_peer_inmates;
sub process_new_inmates;
sub process_jail_sentences;
sub postmap;
sub postsuper;
sub notify_admins;
sub Die;


### MAIN
main;


### SUBROUTINES
sub main {
    initialize;
    while ( !$done ) {
        init_db_vars;
        process_maillogs;
        process_pardons;
        process_inmates;
        process_peer_inmates;
        process_new_inmates;
        process_jail_sentences;
        postmap;
        postsuper;
        notify_admins;
    }
    finalize;
    exit 0;
}


sub initialize {
    $0 = 'postcopd';
    init_signals;
    $| = 1      if  $foreground;  # Autoflush
    init_syslog if !$foreground;
    daemonize   if !$foreground;
    create_locked_pid_file;
    tcp_network_server;
    init_maillog;
    tie_db_vars;
    Log "Postcop started.";
    Log "Threshold rate set to $send_threshold emails per $alarm_time seconds.";
    Log "Mail log processing is set to $alarm_time second intervals.";
    return;
}


sub finalize {
    Log "Postcop finished.";
    unlink glob "$tmpworkdir/*.db";
    unlink $pid_file;
    kill -15, getpgrp;  # sig TERM process group.
    return;
}


sub init_signals {
    $SIG{HUP} = 'IGNORE';
    $SIG{ALRM} = sub { $alarm = 1; };
    $SIG{TERM} = $SIG{INT} = sub { $done = 1; };
    return;
}


sub init_syslog {
    setlogsock $syslog_socktype or die "setlogsock failed ($syslog_socktype): $!";
    openlog $0, 'pid', $syslog_facility;  # Will die on failure (perldoc Sys::Syslog)
    return;
}


sub daemonize {
    # Be inherited by init.
    my $pid = fork;
    $pid < 0 and Die "fork failed (daemonize): $!";
    $pid > 0 and exit 0;  # Lose parent
  
    # Set sane working directory and umask.
    chdir '/' or Die "chdir failed: $!";
    umask 022;
  
    # Establish a new session.
    my $sid = setsid;
    $sid < 0 and Die "setsid failed: $!";

    # Close whatever files that were previously open.
    my $openmax = sysconf(_SC_OPEN_MAX);
    $openmax > 0 or $openmax = 1024;
    POSIX::close $_ for 0 .. $openmax;
  
    # Open std{in,out,err} from/to /dev/null.
    open STDIN,  '<', '/dev/null' or Die "open STDIN failed (/dev/null): $!";
    open STDOUT, '>', '/dev/null' or Die "open STDOUT failed (/dev/null): $!";
    open STDERR, '>', '/dev/null' or Die "open STDERR failed (/dev/null): $!";

    return;
}


sub create_locked_pid_file {
    ## Ensure only one daemon runs at a time.  This lock lasts for the daemon's life.
    ## $pid_fh is global so the filehandle lock doesn't go out of scope.
    $pid_fh = open_file_with_lock $pid_file, O_RDWR|O_CREAT, LOCK_EX|LOCK_NB;
    $pid_fh->truncate(0)   or Die "truncate failed ($pid_file): $!";
    $pid_fh->print("$$\n") or Die "write failed ($pid_file): $!";
    $pid_fh->flush()       or Die "flush failed ($pid_file): $!";
    return;
}


sub open_file_with_lock {
    my ($file, $open_flags, $lock_type) = @_;
    my $fh = IO::File->new($file, $open_flags) or Die "open failed ($file): $!";
    flock $fh, $lock_type or Die "flock failed ($file): $!";
    return $fh;
}


sub tcp_network_server {
    # Simply return if no peers to collaborate with.
    return if !@peers;  # XXX with tcp wrappers, always listen

    # Spawn child network server.
    my $pid = fork;
    $pid < 0 and Die "fork failed (tcp_network_server): $!";
    $pid > 0 and return;  # parent
    # child...

    # Adjust signals accordingly.
    $SIG{ALRM} = $SIG{HUP} = 'IGNORE';
    $SIG{TERM} = $SIG{INT} = sub { $done = 1; };

    # Create tcp network server.
    $listener = IO::Socket::INET->new(LocalAddr => $listen_address,
                                      LocalPort => $listen_port,
                                      Proto     => 'tcp',
                                      Listen    => SOMAXCONN,
                                      Reuse     => 1);
    $listener or Die "listener failed ($listen_address:$listen_port): $!";

    # KEEPALIVE will detect dead peer connections.
    $listener->setsockopt(SOL_SOCKET, SO_KEEPALIVE, 1)
        or Die "setsockopt failed (SOL_SOCKET:SO_KEEPALIVE): $!";

    # Keep track of the number of peer connections.
    my $peer_connections = 0;

    # Iterative server that spawns worker children.
    while ( !$done ) {
        # Accept new peer connection.
        my $peer = $listener->accept or next;

        # Don't exceed max number of peer connections.
        $peer_connections++;
        if ($peer_connections > $max_peer_connections) {
            Log "maximum peer connections reached ($max_peer_connections).";
            Log "Ignoring connection ($peer->peerhost).";
            $peer_connections--;
            next;
        }

        # Service_peer spawns a child worker to service peer.
        service_peer $peer;

        # Reap zombies and adjust peer connection count accordingly.
        $peer_connections-- while (waitpid(-1, WNOHANG) > 0);
    }
    close $listener or Die "close failed (listener): $!";

    kill -15, getpgrp;  # sig TERM to process group.

    exit 0;
}


sub service_peer {
    # Grab peer connection.
    my $peer = shift or return;

    # Don't service self.
    # XXX Even if we query ourselves, the code should work correctly.
    # XXX Consider taking this line out.
    #return if $peer->peerhost eq $listen_address;

    # Spawn a child worker to service peer.
    my $pid = fork;
    $pid < 0 and Die "fork failed (service_peer): $!";
    if ($pid > 0) {  # Parent.
        # For child only.  Parent can close.
        close $peer or Die "close failed (parent peer): $!";
        return;
    }
    # Child...

    # For parent only.  Child can close.
    close $listener or Die "close failed (listener): $!";

    # Adjust signals accordingly.
    $SIG{ALRM} = $SIG{HUP} = $SIG{PIPE} = 'IGNORE';
    $SIG{TERM} = $SIG{INT} = sub { $done = 1; };

    # Only service recognized peers.
    # XXX With tcpwrappers, this isn't needed.
    if (none { $peer->peerhost eq $_ } @peers) {
        Log "Unrecognized peer connection ($peer->peerhost).";
        close $peer or Die "close failed (unrecognized peer $peer->peerhost): $!";
        exit 0;
    }

    Log "Sharing jailings with peer ($peer->peerhost).";

    # Share your jailings with peer.
    my $jailfh = open_file_with_lock $jail_file, O_RDONLY|O_CREAT, LOCK_SH;
    while (!$done and my $line = <$jailfh>) {
        print $peer $line;
    }
    close $jailfh or Die "close failed ($jail_file): $!";
    close $peer   or Die "close failed (child peer): $!";

    kill -15, getpgrp;  # sig TERM to process group.

    exit 0;
}


sub init_maillog {
    # Open mail log.
    my $open_attempts = 5;
    while ($open_attempts--) {
        $maillog_fh = IO::File->new($maillog_file, O_RDONLY);
        $maillog_fh and last;
        sleep 1;
    }
    $maillog_fh or Die "open failed ($maillog_file): $!";

    # The inode is used to deduce when a log rotation occurs.
    $maillog_inode = stat($maillog_fh)->ino or Die "stat failed: $!";

    # When processing the mail log and there's no activity, go to sleep until
    # a mail log event occurs via the Linux inotify mechanism.  Perhaps this
    # is better than just explicitly sleeping for a set time period.
    $inotify = Linux::Inotify2->new or Die "inotify new error: $!";
    $inotify->watch(readlink('/proc/'.$$.'/fd/'.fileno($maillog_fh)), IN_ALL_EVENTS)
        or Die "inotify watch error: $!";

    # Log rotated so start at beginning (not end) of new log file.
    if ($maillog_rotated) {
        $maillog_rotated = 0;
    }
    # Postcop just started so seek to end of current log file for processing.
    else {
        $maillog_fh->seek(0, SEEK_END) or Die "seek failed ($maillog_file): $!";
    }

    return;
}


sub Log {
    my $log = shift;

    if ($foreground) {
        print '['.scalar(localtime(time)).'] '."$log\n";
        STDOUT->flush;
    }
    else {
        syslog $syslog_priority, $log;
    }

    return;
}


sub tie_db_vars {
    # Hashes are tied to files for the purpose of avoiding memory exhaustion.
    tie %sender_mail_counts, 'DBM::Deep', $tmpworkdir.'/sender_mail_counts.db'
        or Die "Tie failed (sender_mail_counts): $!";
    tie %sender_mail_ids, 'DBM::Deep', $tmpworkdir.'/sender_mail_ids.db'
        or Die "Tie failed (sender_mail_ids): $!";
    tie %sender_mail_logs, 'DBM::Deep', $tmpworkdir.'/sender_mail_logs.db'
        or Die "Tie failed (sender_mail_logs): $!";
    tie %inmates, 'DBM::Deep', $tmpworkdir.'/inmates.db'
        or Die "Tie failed (inmates): $!";
    tie %new_inmates, 'DBM::Deep', $tmpworkdir.'/new_inmates.db'
        or Die "Tie failed (new_inmates): $!";
    tie %peer_inmates, 'DBM::Deep', $tmpworkdir.'/peer_inmates.db'
        or Die "Tie failed (peer_inmates): $!";
    tie %pardons, 'DBM::Deep', $tmpworkdir.'/pardons.db'
        or Die "Tie failed (pardons): $!";
    return;
}


sub init_db_vars {
    %sender_mail_counts = ();
    %sender_mail_ids    = ();
    %sender_mail_logs   = ();
    %inmates            = ();
    %new_inmates        = ();
    %peer_inmates       = ();
    %pardons            = ();
    return;
}


sub process_maillogs {
    # Set the interval for monitoring the mail log.
    # Read and process the mail log through interval duration.
    alarm $alarm_time;
    while (!$alarm and !$done) {
        # Attempt to read a line from the mail log.
        my $line = <$maillog_fh>;

        # Handle end of file situation.
        if ($maillog_fh->eof) {
            # Ignore EOF (Clear EOF state).
            $maillog_fh->clearerr;

            # If log rotated, set an indicator flag.
            if ($maillog_file ne readlink('/proc/'.$$.'/fd/'.fileno($maillog_fh))) {
                $maillog_rotated = 1;
            }

            Log "Maillog rotated." if $debug and $maillog_rotated;

            # if EOF and log rotated, open new log.
            if ($maillog_rotated) {
                init_maillog;
            }
            # if EOF and log not rotated, sleep until next log event.
            else {
                $inotify->read;
            }
        }

        # EOF will render an undefined line.  Try read again.
        next if !defined $line;

        # Remove newline.
        chomp $line;

        # Parse log line.  Find and extract the mail ID, sender
        # and number of recipients.  This regular expression is
        # critical to the functionality of Postcop and needs to
        # be tailored to your version of Postfix logs.
        # $maillog_regexp is a global variable that can be found
        # toward the beginning of this Postcop program.
        next if $line !~ $maillog_regexp;

        # Disregard bogus data.  Postcop requires all three.
        next if !defined $1;
        next if !defined $2;
        next if !defined $3;

        # Assign extracted data to appropriate variables.
        my ($mailid, $sender, $nrcpts) = ($1, lc $2, $3);

        # Disregard logs with duplicate mail IDs.
        next if any { $mailid eq $_ } @{ $sender_mail_ids{$sender} };

        # Populate data structures for later processing.
        Log 'push @{ $sender_mail_ids{'.$sender.'} }, '.$mailid if $debug;
        push @{ $sender_mail_ids{$sender}  }, $mailid;

        Log 'push @{ $sender_mail_logs{'.$sender.'} }, '.$line if $debug;
        push @{ $sender_mail_logs{$sender} }, $line;

        Log '$sender_mail_counts{'.$sender.'} += '.$nrcpts if $debug;
        $sender_mail_counts{$sender} += $nrcpts;
    }
    $alarm = 0;  # Reset alarm flag.

    return;
}


sub process_pardons {
    # Postcop is above the law; Pardon $from.
    $pardons{$from} = '1';  # Appease compiler with assignment.

    # Iterate pardons.
    # Parse the pardon file.  File consists of line separated regexps.
    my $pardonfh = open_file_with_lock $pardon_file, O_RDONLY|O_CREAT, LOCK_SH;
    while (my $line = <$pardonfh>) {
        # Remove newline.
        chomp $line;

        # Verify the regular expression is valid.
        eval { my $is_valid_regexp = qr/$line/; };
        if ($@) {
            Log "Invalid regular expression ($pardon_file): $line";
            next;
        }

        # Populate data structures for later processing.
        Log "\$pardons{$line}" if $debug;
        $pardons{$line} = '1';  # Appease compiler with assignment.
    }
    close $pardonfh or Die "close failed ($pardon_file)";

    return;
}


sub process_inmates {
    # Time now is for calculating current jail durations.
    my $now = time;

    # Interate inmates.
    # Determine if inmates are freed or not.
    my $jailfh = open_file_with_lock $jail_file, O_RDONLY|O_CREAT, LOCK_SH;
    while (my $line = <$jailfh>) {
        # Remove newline.
        chomp $line;

        # Match a valid jail entry or ignore it verbosely.
        if ($line !~ $jailing_regexp) {
            Log "Ignoring malformed jail entry: $line";
            next;
        }

        # Assign extracted data to appropriate variables.
        my ($sender, $then) = (lc $1, $2);

        # Verify good data or ignore verbosely.
        if (!defined($sender) and !defined($then)) {
            Log "Ignoring malformed jail entry: $line";
            next;
        }

        # Free inmates that served their jail sentence.
        if ( ($now - $then) >= $jail_time ) {
            Log "$sender has been freed from jail (sentence expired).";
            next;
        }

        # Free inmates that have been pardoned.
        if (is_pardoned($sender)) {
            Log "$sender has been freed from jail (pardoned).";
            next;
        }

        # Populate data structures for later processing.
        Log "\$inmates{$sender} = $line" if $debug;
        $inmates{$sender} = $line;
    }
    close $jailfh or Die "close failed ($jail_file): $!";

    return;
}


sub process_peer_inmates {
    # Time now is for timestamping peer jail transfers.
    my $now = time;

    # Iterate peers.
    # Determine if inmate transfers are required or not.
    PEERS:
    for my $peer (@peers) {
        # Don't query self.
        next PEERS if $peer eq $listen_address;

        # Create TCP network connection to peer.
        my $sock = IO::Socket::INET->new(PeerAddr => $peer, PeerPort => $listen_port, Timeout  => 5);

        # Verify a good socket.
        if (!$sock) {
            Log "sock failed ($peer:$listen_port): $!";
            next PEERS;
        }

        # Iterate peer jailings.
        JAILINGS:
        while (my $line = <$sock>) {
            # Remove newline.
            chomp $line;

            # Jail policies (ie $postfix_access) must be identical for inmate transfers.
            if ($line !~ $jailing_regexp) {
                Log "Ignoring malformed jail entry: $line";
                next JAILINGS;
            }
            
            # Assign extracted data to appropriate variables.
            my ($sender, $then) = (lc $1, $2);

            # Verify good data or ignore verbosely.
            if (!defined($sender) and !defined($then)) {
                Log "ignoring malformed jail entry: $line";
                next JAILINGS;
            }

            # Ignore sender if already processed.
            next if is_pardoned($sender);
            next if is_inmate($sender);

            # Populate data structures for later processing.
            Log "$sender has been sentenced jail time via peer collaboration ($peer).";
            Log "\$peer_inmates{$sender} = $sender $postfix_access [$now]" if $debug;
            $peer_inmates{$sender} = "$sender $postfix_access [$now]";
        }  # end JAILINGS

        close $sock;

    }  # end PEERS

    return;
}


sub process_new_inmates {
    # Time now is for timestamping peer jail transfers.
    my $now = time;

    # Iterate new senders.
    # Determine who goes to jail.
    while (my ($sender, $count) = each %sender_mail_counts) {
        # Verify good data.
        next if !defined $sender;
        next if !defined $count;

        # Ignore compliant senders.
        next if $count < $send_threshold;

        # Ignore sender if already processed.
        next if is_pardoned($sender);
        next if is_inmate($sender);
        next if is_peer_inmate($sender);

        Log "$sender has been jailed ($count emails per $alarm_time seconds).";

        if ($debug) {
            while (my (undef, $mail_log) = each @{ $sender_mail_logs{$sender} }) {
                Log $mail_log;
            }
        }

        # Populate data structures for later processing.
        Log "\$new_inmates{$sender} = $sender $postfix_access [$now]" if $debug;
        $new_inmates{$sender} = "$sender $postfix_access [$now]";
    }

    return;
}


sub process_jail_sentences {
    # Iterate through processed data structures and perform jailings.
    # In other words, write the postfix access rules to the postmapable
    # jail file.  The postmap command will later be executed on the jail file
    # to put the new jailing into affect.

    my $jailfh = open_file_with_lock $jail_file, O_WRONLY|O_CREAT|O_TRUNC, LOCK_EX;

    # Jail existing inmates.
    while (my (undef, $jailing) = each %inmates) {
        Log "print \$jailfh $jailing" if $debug;
        print $jailfh "$jailing\n" or Die "write failed ($jail_file): $!";
    }

    # Jail peer inmates.
    while (my (undef, $jailing) = each %peer_inmates) {
        Log "print \$jailfh $jailing" if $debug;
        print $jailfh "$jailing\n" or Die "write failed ($jail_file): $!";
    }

    # Jail new inmates.
    while (my (undef, $jailing) = each %new_inmates) {
        Log "print \$jailfh $jailing" if $debug;
        print $jailfh "$jailing\n" or Die "write failed ($jail_file): $!";
    }

    close $jailfh or Die "close failed ($jail_file): $!";

    return;
}


sub postmap {
    # Implement new jailings via Postfix' postmap command.
    my $ret = system($postmap_cmd);
    Die "system failed ($postmap_cmd): returned $ret: $!"
        if $ret != 0;
    return;
}


sub postsuper {
    # Return if nothing to do.
    return if !%new_inmates;

    # Open pipe to Postfix' postsuper command.
    open my $pipefh, '|-', $postsuper_cmd
        or Die "open pipe failed ($postsuper_cmd): $!";

    # Mail IDs will be written to postsuper via stdin.
    while (my ($new_inmate, undef) = each %new_inmates) {
        my $mail_ids_aref = $sender_mail_ids{$new_inmate};

        while (my (undef, $mail_id) = each @{ $mail_ids_aref }) {
            # Write mail ID to postsuper's stdin via pipe.
            print $pipefh "$mail_id\n";
        }
    }

    close $pipefh or Die "close failed (pipefh): $!";

    return;
}


sub notify_admins {
    # Return if nothing to do.
    return if !%new_inmates;

    # Build body; Newline separated list of new jailings.
    my $body;
    while (my ($new_inmate, undef) = each %new_inmates) {
        $body .= "$new_inmate\n";
    }

    # Build email.
    my $email = Email::Simple->create(header => $header, body => $body);

    # Best effort attempt to send new jailings to admin address.
    # Utilizes system sendmail command.
    try_to_sendmail($email) or Log "try_to_sendmail failed: $!";

    return;
}


sub Die {
    my $msg = shift;
    Log $msg;
    Log "Postcop died unexpectedly.";
    kill -15, getpgrp;  # Sig TERM process group.
    exit 1;
}


sub is_pardoned {
    my $sender = shift;
    return exists $pardons{$sender};
}


sub is_inmate {
    my $sender = shift;
    return defined $inmates{$sender};
}


sub is_peer_inmate {
    my $sender = shift;
    return defined $peer_inmates{$sender};
}


